#include <iostream>
using namespace std;

struct node//структура, описывающая состав звена
{
    int elem;//объвление информационного поля в звене
    node* sled;//объявление указателя на следующее звено дека
    node* pred;//объявление указателя на предыдущее звено дека
};

class Spisok
{
private:
    node* nd;//Указатель на начало дека.
    node* kd;//Указатель на конец  дека.
    int klad;//Информационное поле удаленного элемента.
public:
    void BuiltDeck();//прототип функции, создающей дек
    void VyvodDeck();//прототив функции,выводящей дек
    void InsLeft(int);//прототив функции,вставляющий элемнет дека в левый конец
    void InsRight(int);//прототив функции,вставляющий элемнет дека в правый конец
    void DelLeft();//прототив функции,удаляющей элемнет дека с левого конца
    void DelRight();//прототив функции,удаляющей элемнет дека с правого конца
    int Get_Klad() { return klad; }//прототив функции, которая возвращает удалённый элемент
    void Ochistka();//прототип функции очистки дека
};

void main()
{
    setlocale(LC_ALL, "Rus");//определение локали, для вывода славянских символом
    Spisok A;//объявление  
    int el;//объявление  перемееной, которая будет вставляться

    A.BuiltDeck();//вызов функции создания дека
    A.VyvodDeck();//вывод полученного дека
    cout << "Введите элемент звена, вставляемого справа: ";
    cin >> el; A.InsRight(el); A.VyvodDeck();//ввод элемента, вставка его в правый конец, и вывод полученного дека
    cout << "Введите элемент звена, вставляемого слева: ";
    cin >> el; A.InsLeft(el); A.VyvodDeck();//ввод элемента, вставка его в левый конец, и вывод полученного дека
    cout << "Удалим звено справа: \n";
    A.DelRight(); A.VyvodDeck();//выхов функции удаления элемента в правом конце, и вывод полученного дека
    cout << "Был удален элемент: " << A.Get_Klad() << endl;//вызов функции возвращения удалённого элемента
    cout << "Удалим звено слева: \n";
    A.DelLeft(); A.VyvodDeck();//выхов функции удаления элемента в левом конце, и вывод полученного дека
    cout << "Был удален элемент: " << A.Get_Klad() << endl;//вызов функции возвращения удалённого элемента
    A.Ochistka();//вызов функции очистки дека

    cout << "\n";
    system("PAUSE");
}

void Spisok::BuiltDeck()
// Функция для построения двунаправленного списка с заглавным звеном в качестве дека.
// nd - указатель на начало дека,
// *kd - указатель на конец дека.
{
    node* q; // Объявление указателя на узел для временного хранения значения.
    node* z; // Объявление указателя на узел для добавления нового элемента.
    int  el; // Объявление переменной для временного хранения элемента дека.

    nd = new(node); // Выделение памяти для заглавного звена.
    z = nd; // Установка указателя на последний узел в начало дека.
    (*nd).pred = (*nd).sled = NULL; // Инициализация указателей на предыдущий и следующий узлы заглавного звена как NULL.
    cout << "Введите последовательность: \n"; // Приглашение пользователя ввести последовательность.
    cin >> el; // Считывание первого элемента последовательности.
    while (el != 0) // Цикл для добавления элементов последовательности в дек, пока не будет введен нулевой элемент.
    {
        (*z).sled = new (node); // Выделение памяти для нового узла дека.
        (*((*z).sled)).pred = z; // Установка указателя на предыдущий узел нового узла на текущий узел.
        z = (*z).sled; (*z).sled = NULL; // Переход указателя на последний узел на новый узел и установка указателя на следующий узел нового узла на NULL.
        (*z).elem = el; cin >> el; // Запись элемента последовательности в новый узел и считывание следующего элемента последовательности.
    }
    if ((*nd).sled != NULL) // Если после добавления элементов в деке есть хотя бы один элемент,
    {
        q = nd; // Сохранение указателя на заглавное звено во временную переменную.
        nd = (*nd).sled; (*nd).pred = NULL; // Перемещение указателя на начало дека на первый узел и установка указателя на предыдущий узел первого узла как NULL.
        kd = z; // Установка указателя на конец дека на последний узел.
        delete q; // Освобождение памяти, выделенной для заглавного звена.
    }
    else // Если после добавления элементов в деке нет ни одного элемента,
    {
        delete nd; nd = kd = NULL; // Освобождение памяти, выделенной для заглавного звена, и установка указателей в ноль
    }
}

void Spisok::VyvodDeck()
// Функция для вывода содержимого дека на экран.
// nd - указатель на начало дека.
{
    node* z; // Объявление указателя на узел для перебора элементов дека.

    z = nd; cout << "Содержимое дека: "; // Установка указателя на начало дека и вывод заголовка.
    if (z != NULL) // Если дек не пуст,
        while (z != NULL) // цикл для перебора всех элементов дека.
        {
            cout << (*z).elem << " "; // Вывод значения текущего элемента.
            z = (*z).sled; // Переход к следующему элементу дека.
        }
    else  cout << "он пуст!\n"; // Вывод сообщения о том, что дек пуст.
    cout << endl; // Переход на новую строку.
}

void Spisok::InsLeft(int el)
// Функция для добавления нового элемента в начало дека.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
    node* q; // Объявление указателя на новый узел.

    q = new(node); // Создание нового узла.
    (*q).elem = el; // Запись значения в новый узел.
    if (nd == NULL) // Если дек пуст,
    {
        nd = q; (*q).sled = (*q).pred = NULL; kd = q; // Установка указателей на новый узел.
    }
    else // Если дек не пуст,
    {
        (*q).sled = nd; (*q).pred = NULL; // Установка указателей на новый узел.
        (*nd).pred = q; nd = q; // Установка указателей на начало дека.
    }
}


void Spisok::InsRight(int el)
// Функция для добавления нового элемента в конец дека.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
    node* q; // Объявление указателя на новый узел.

    q = new(node); // Создание нового узла.
    (*q).elem = el; // Запись значения в новый узел.
    if (kd == NULL) // Если дек пуст,
    {
        nd = q; (*q).sled = (*q).pred = NULL; kd = q; // Установка указателей на новый узел.
    }
    else // Если дек не пуст,
    {
        (*q).sled = NULL; (*q).pred = kd; // Установка указателей на новый узел.
        (*kd).sled = q; kd = q; // Установка указателей на конец дека.
    }
}

void Spisok::DelLeft()
// Функция для удаления элемента из начала дека.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
    node* q; // Объявление указателя на узел.

    if ((*nd).sled != NULL) // Если в деке больше одного элемента,
    {
        q = nd; klad = (*q).elem; // Сохранение значения элемента, который нужно удалить.
        nd = (*nd).sled; (*nd).pred = NULL; delete q; // Изменение указателей и удаление элемента.
    }
    else // Если в деке один элемент,
    {
        q = nd; klad = (*q).elem; // Сохранение значения элемента, который нужно удалить.
        nd = kd = NULL; delete q; cout << "Дек пуст!\n"; // Изменение указателей и удаление элемента.
    }
}


void Spisok::DelRight()
// Удаление звена из дека справа с помещением
// элемента удаляемого звена в переменную klad.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
    node* q;//объявление указателя на узел.
  
    if ((*kd).pred != NULL)  // Если в деке больше одного элемента, удаляем звено справа.
    {
        q = kd; // сохраняем указатель на удаляемое звено
        klad = (*q).elem; // сохраняем элемент удаляемого звена в переменную klad
        kd = (*kd).pred; // переносим указатель на конец дека на предыдущее звено
        (*kd).sled = NULL; // устанавливаем указатель следующего звена равным NULL
        delete q; // удаляем звено
    }
   
    else // Если в деке только одно звено, удаляем его.
    {
        q = kd; // сохраняем указатель на удаляемое звено
        klad = (*q).elem; // сохраняем элемент удаляемого звена в переменную klad
        nd = kd = NULL; // устанавливаем указатели на начало и конец дека равными NULL
        delete q; // удаляем звено
        cout << "Дек пуст!\n"; // выводим сообщение о том, что дек пуст
    }

}

void Spisok::Ochistka()
{
    node* q, * q1;//объявление указателей. Первый на начало дека, второй - на следующий элемент дека

    q = nd;//инициализация указателя на начало дека
    q1 = (*q).sled;//инициализация указателся на следующий элемнет дека
    while (q1 != NULL)//пока опережающий указатель не дойдёт до канца дека
    {
        delete q; q = q1; q1 = (*q).sled;//удаление адреса звена, инициализация его на следующий элемент, инициализация следующего элемента на следующий за ним 
    }
    delete q;//удаление последнего элемента дека
    nd = kd = NULL;//инициализация концов дека 
}
